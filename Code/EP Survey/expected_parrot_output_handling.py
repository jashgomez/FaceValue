# -*- coding: utf-8 -*-
"""Expected Parrot Output Handling.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-paUWNAEQXSJoG_rlydJvGXx_0VIfEyd
"""

# Required packages
import pandas as pd
import numpy as np
import statsmodels.formula.api as smf
from statsmodels.stats.outliers_influence import variance_inflation_factor
from scipy.stats.mstats import winsorize
# File in/out access
from google.colab import drive
drive.mount('/content/drive')

# -------------- 1. Load the data ----------------------
dir = "/content/drive/MyDrive/Colab Notebooks/Axion FIN 377 Final Project/inputs/"
df = pd.read_csv(dir+"clean_data_with_stock_info.csv")
df

# -------------- 2. basic cleaning ----------------------
# ensure Year is int
df['scenario.Year'] = df['scenario.Year'].astype(int)
df['Year'] = df['scenario.Year']   # if you prefer consistent name

# drop rows with missing ticker or year
df = df.dropna(subset=['Ticker', 'Year'])

# -------------- 3. create forward-looking DV ------------
# We'll use next-year Year_Cum_Ret_Overall as the outcome (so expectation precedes performance)
df = df.sort_values(['Ticker', 'Year'])
df['Y_next'] = df.groupby('Ticker')['year_cum_ret_overall'].shift(-1)

# If you prefer market-cap growth as alt DV:
df['log_MktCap'] = np.log(df['Market_Cap'].replace(0, np.nan))
df['log_MktCap_next'] = df.groupby('Ticker')['log_MktCap'].shift(-1)
df['mktcap_growth'] = df['log_MktCap_next'] - df['log_MktCap']

# drop rows where DV is missing (i.e., last year for each firm)
df = df.dropna(subset=['Y_next'])   # use ['mktcap_growth'] for that DV alternative

# -------------- 4. winsorize numeric controls (optional) -----------
def winsorize_series(s, limits=(0.01, 0.01)):
    try:
        return winsorize(s, limits=limits)
    except:
        return s

numeric_cols = ['Market_Cap', 'Full_Time_Employees', 'Return']  # add more if needed
for c in numeric_cols:
    if c in df.columns:
        df[c + '_w'] = winsorize_series(df[c].astype(float).fillna(df[c].median()))

# -------------- 5. scaling / standardizing ----------------
# Option A: cross-sectional z-score within each year (makes comparisons within-year)
scale_cols = ['Market_Cap_w', 'Full_Time_Employees']  # add any continuous controls
for col in scale_cols:
    if col in df.columns:
        df[col + '_z'] = df.groupby('Year')[col].transform(lambda x: (x - x.mean()) / x.std(ddof=0))

# Option B: global z-score across entire sample (use instead of A if you prefer)
# for col in scale_cols:
#     df[col + '_z_global'] = (df[col] - df[col].mean())/df[col].std(ddof=0)

# -------------- 6. create industry dummies or include as FE ------------
# If you want industry fixed effects by e.g. Sector or Industry:
df['Sector'] = df['Sector'].fillna('Unknown')
# create dummies only if you have small number of sectors; otherwise use FE approach below
sector_dummies = pd.get_dummies(df['Sector'], prefix='sector', drop_first=True)
df = pd.concat([df, sector_dummies], axis=1)

# -------------- 7. define model formula ----------------
# Core independent variable: expected_performance_factor
# Controls: market cap z-score, employees z-score, CEO features (scenario.*), survey answers (answer.*)
controls = []
if 'Market_Cap_w_z' in df.columns:
    controls.append('Market_Cap_w_z')
elif 'Market_Cap_z' in df.columns:
    controls.append('Market_Cap_z')

if 'Full_Time_Employees_z' in df.columns:
    controls.append('Full_Time_Employees_z')

# add some example controls from your data (adjust names if needed)
for name in ['scenario.Age', 'scenario.dominant_gender', 'scenario.dominant_race']:
    if name in df.columns:
        # convert categorical where appropriate
        if df[name].dtype == object:
            df[name] = df[name].astype('category')
            # add as categorical in formula using C()
            controls.append(f'C({name})')
        else:
            controls.append(name)

# add sector dummies if you prefer
controls += [c for c in df.columns if c.startswith('sector_')]

# Build formula
indep = 'expected_performance_factor'
formula = 'Y_next ~ ' + indep
if controls:
    formula += ' + ' + ' + '.join(controls)

import statsmodels.formula.api as smf

# ------------------- 8. Main Regression with Y_next -------------------

# Build control variables
controls = []

if 'Market_Cap_w_z' in df.columns:
    controls.append('Market_Cap_w_z')
elif 'Market_Cap_z' in df.columns:
    controls.append('Market_Cap_z')

if 'Full_Time_Employees_z' in df.columns:
    controls.append('Full_Time_Employees_z')

# Handle scenario variables
for var in ['scenario.Age', 'scenario.dominant_gender', 'scenario.dominant_race']:
    if var in df.columns:
        if df[var].dtype == object:
            df[var] = df[var].astype('category')
            controls.append(f'C(Q("{var}"))')
        else:
            controls.append(f'Q("{var}")')

# Add sector dummies if they exist
sector_dummies = [c for c in df.columns if c.startswith('sector_')]
controls.extend(sector_dummies)

# Independent variable
indep = "Q('answer.Projected_risk_taking')"

# Full formula with controls
formula = 'Y_next ~ ' + indep
if controls:
    formula += ' + ' + ' + '.join(controls)

# Add firm and year fixed effects
formula_fe = formula + ' + C(Ticker) + C(Year)'

# Fit model with clustered SEs by firm
model_fit_obj = smf.ols(formula_fe, data=df).fit()
filtered_groups = df.loc[model_fit_obj.model.data.row_labels, 'Ticker']

model = smf.ols(formula_fe, data=df).fit(cov_type='cluster', cov_kwds={'groups': filtered_groups})
print(model.summary())

import statsmodels.formula.api as smf

model = smf.ols(
    formula = """
        Y_next ~
          Q("scenario.Age") +
          Q("scenario.dominant_gender") +
          Q("scenario.dominant_race") +
          Q("scenario.dominant_emotion") +
          C(Industry) +
          C(Year)
    """,
    data = df
).fit(cov_type='HC3')

print(model.summary())

import statsmodels.formula.api as smf

model = smf.ols(
    formula = """
        Y_next ~
          expected_performance_factor
    """,
    data = df
).fit(cov_type='HC3')

print(model.summary())

# -------------- 9. Diagnostics ----------------
# VIF for numeric regressors (exclude categorical dummies)
num_for_vif = []
# Combine indep and controls, then iterate through them
# Filter controls to only include those not explicitly marked as categorical (C()) or sector dummies
candidate_cols_for_vif_formula = [indep] + [c for c in controls if 'C(' not in c and not c.startswith('sector_')]

for t in candidate_cols_for_vif_formula:
    # Ensure to unquote variable names for VIF calculation if they were quoted for patsy
    unquoted_t = t.replace('Q("', '').replace('")', '').replace("'", "")
    if unquoted_t in df.columns:
        # Add to num_for_vif only if the column is numeric
        if pd.api.types.is_numeric_dtype(df[unquoted_t]):
            num_for_vif.append(unquoted_t)
vif_df = None
if num_for_vif:
    # Filter df to include only rows used in the model to avoid length mismatch for VIF
    X = df.loc[model_fit_obj.model.data.row_labels, num_for_vif].dropna()
    if not X.empty and X.shape[1] > 1: # VIF needs at least 2 variables
        vif = pd.DataFrame()
        vif['variable'] = X.columns
        vif['VIF'] = [variance_inflation_factor(X.values, i) for i in range(X.shape[1])]
        print("\n--- Variance Inflation Factor (VIF) ---")
        print(vif)
    else:
        print("\nNot enough numeric variables for VIF calculation or data is empty after filtering.")
else:
    print("\nNo numeric variables found for VIF calculation.")

# ------------------- 10. Robustness Check with Y_next -------------------

# You can choose a slightly simpler formula if desired
robust_formula = 'Y_next ~ ' + indep
if controls:
    robust_formula += ' + ' + ' + '.join(controls)

# Fit robust model with clustered SEs
robust_model_fit_obj = smf.ols(robust_formula, data=df).fit()
filtered_groups_robust = df.loc[robust_model_fit_obj.model.data.row_labels, 'Ticker']

robust_model = smf.ols(robust_formula, data=df).fit(cov_type='cluster', cov_kwds={'groups': filtered_groups_robust})
print("\n--- Robustness Check ---")
print(robust_model.summary())